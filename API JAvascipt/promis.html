<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body style="background-color: rgb(204, 197, 195);">
    <div style="font-size: 2rem;">
        <img style="padding-left: 400px;"
            src="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/promises.png"
            alt="">
        <!-- Corrected <P> to <p> and removed extra tags -->
        <p style="font-size: 3rem; padding-left: 600px;">Promises In JS</p>
        <span> <b>A Promise is a proxy for a value not necessarily known when the promise is created. It allows you
                to
                associate handlers with an asynchronous action's eventual success value or failure reason. This lets
                asynchronous methods return values like synchronous methods: instead of immediately returning the
                final
                value, the asynchronous method returns a promise to supply the value at some point in the
                future.</b></span>
        <br>
        <br>
        A Promise is in one of these states:
        <br>
        <br>
        <span>
            pending: initial state, neither fulfilled nor rejected.
            fulfilled: meaning that the operation was completed successfully.
            rejected: meaning that the operation failed.
            The eventual state of a pending promise can either be fulfilled with a value or rejected with a reason
            (error). When either of these options occur, the associated handlers queued up by a promise's then
            method are called. If the promise has already been fulfilled or rejected when a corresponding handler is
            attached, the handler will be called, so there is no race condition between an asynchronous operation
            completing and its handlers being attached.
        </span>
        <h1>The finally() method of Promise instances schedules a function to be called when the promise is settled
            (either fulfilled or rejected). It immediately returns another Promise object, allowing you to chain calls
            to other promise methods.</h1>
        <h1>The catch() method of Promise instances schedules a function to be called when the promise is rejected. It
            immediately returns another Promise object, allowing you to chain calls to other promise methods. It is a
            shortcut for Promise.prototype.then(undefined, onRejected).</h1>
        <h1>The then() method of Promise instances takes up to two arguments: callback functions for the fulfilled and
            rejected cases of the Promise. It immediately returns another Promise object, allowing you to chain calls to
            other promise methods.</h1>

        <h1>Example Of Catch</h1>
        <p>const promise1 = new Promise((resolve, reject) => {
            throw new Error('Uh-oh!');
            });

            promise1.catch((error) => {
            console.error(error);
            });
            // Expected output: Error: Uh-oh!
        </p>
        <h1>Example Of finally</h1>
        <p>function checkMail() {
            return new Promise((resolve, reject) => {
            if (Math.random() > 0.5) {
            resolve('Mail has arrived');
            } else {
            reject(new Error('Failed to arrive'));
            }
            });
            }

            checkMail()
            .then((mail) => {
            console.log(mail);
            })
            .catch((err) => {
            console.error(err);
            })
            .finally(() => {
            console.log('Experiment completed');
            });</p>
        <p>Example Of Then</p>
        <h1>const promise1 = new Promise((resolve, reject) => {
            resolve('Success!');
            });

            promise1.then((value) => {
            console.log(value);
            // Expected output: "Success!"
            });
        </h1>
    </div>
</body>
<script>
    const promiseone = new Promise(function (resolve, reject) {
        setTimeout(function () {
            console.log("Async task Is a Computer");
            resolve();

        }, 1000)
    });

    promiseone.then(function () {
        console.log("Hello Run");
    });

    new Promise(function (resolve, reject) {
        setTimeout(function () {
            console.log("Hello ");
            resolve()
        }, 1000)
    }).then(function () {
        console.log("Resolved")
    });

    //DATA CONSUMPTION,VALUE INPUT
    // Changed 'new promisetwo = new Promise' to 'const promisetwo = new Promise'
    const promisetwo = new Promise(function (resolve, reject) {
        setTimeout(() => {
            resolve({ username: "Dhruba", email: "user@gmail.com" })
        }, 1000);
    })
    promisetwo.then(function (user) {
        console.log(user);
    })






    //error 
    const promisefour = new Promise(function (resolve, reject) {
        setTimeout(() => {
            const error = true;
            // const error = false;
            if (!error) { // Fixed if condition to use 'error' variable
                resolve({ user: "Dhurba", pass: "123" })
            }
            else {
                reject('Something Went Wrong')
            }

        }, 1000);

    });
    promisefour.then((user) => {
        console.log(user);
        return user.username
    })
        //THEN CATCH AND FINALLY
        .then((username) => {
            console.log(username);

        })
        .catch(function (error) {
            console.log(error)
        })
        .finally(() => console.log("The Promise Was Successfully Run"))

    //PROCESS DIFFERENT SAME WORK

    const promiseerror = new Promise(function (resolve, reject) {
        setTimeout(() => {
            //let error = true;
            let error = false;
            if (!error) {
                resolve({ username: "Dhruba", password: "123" });
            }
            else {
                reject('Error:Went Wrong Bro')
            }
        }, 1000);
    });


    async function asyncpromise() {
        try {
            const response = await asyncpromise;
            console.log(response)
        } catch (error) {
            consoel.log(error)
        }
    }
    asyncpromise();




    // async function getAllUsers(){
    //     try {
    //         const response = await fetch('https://jsonplaceholder.typicode.com/users')

    //         const data = await response.json()
    //         console.log(data);
    //     } catch (error) {
    //         console.log("E: ", error);
    //     }
    // }

    //getAllUsers()

    fetch('https://api.github.com/users/dhruba2807')
        .then((response) => {
            return response.json()
        })
        .then((data) => {
            console.log(data);
        })
        .catch((error) => console.log(error))



    let fruits = ["Apple", "Banana", "Strawberry"]; // Corrected spelling from 'Stwabery' to 'Strawberry'

    const animateone = (fruit, animate) => {
        return new Promise((resolve, reject) => {
            setTimeout(() => {
                animate(fruit);
                resolve(true);

            }, 1000)
        });
    };

    const animateAll = (animate) => {
        animateone(fruits[0], animate)
            .then(() => animateone(fruits[1], animate))
            .then(() => animateone(fruits[2], animate))
            .catch((error) => console.log("Some Error Occurred"));
    };

    const animate = (fruit) => {
        console.log("animating", fruit);
    }

</script>

</html>